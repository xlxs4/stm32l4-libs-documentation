<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32L4xx_HAL_Driver: Configuration of ADC hierarchical scope: group regular</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STM32L4xx_HAL_Driver
   &#160;<span id="projectnumber">1.14.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ADC__LL__EF__Configuration__ADC__Group__Regular.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Configuration of ADC hierarchical scope: group regular<div class="ingroups"><a class="el" href="group__STM32L4xx__LL__Driver.html">STM32L4xx_LL_Driver</a> &raquo; <a class="el" href="group__ADC__LL.html">ADC</a> &raquo; <a class="el" href="group__ADC__LL__Exported__Functions.html">ADC Exported Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga46331bb05afe971e9ad6b54efd5f07ee">LL_ADC_REG_SetTriggerSource</a> (ADC_TypeDef *ADCx, uint32_t TriggerSource)</td></tr>
<tr class="memdesc:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line).  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga46331bb05afe971e9ad6b54efd5f07ee">More...</a><br /></td></tr>
<tr class="separator:ga46331bb05afe971e9ad6b54efd5f07ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga881dbc8fa2421ca421677fdb4f1a4b6e">LL_ADC_REG_GetTriggerSource</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line).  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga881dbc8fa2421ca421677fdb4f1a4b6e">More...</a><br /></td></tr>
<tr class="separator:ga881dbc8fa2421ca421677fdb4f1a4b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaaa50f143fbbb1df8671053e1a7aec8c3">LL_ADC_REG_IsTriggerSourceSWStart</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger source internal (SW start) or external.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaaa50f143fbbb1df8671053e1a7aec8c3">More...</a><br /></td></tr>
<tr class="separator:gaaa50f143fbbb1df8671053e1a7aec8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50ae71c40ac2f5ffaf335cb08451fea6"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga50ae71c40ac2f5ffaf335cb08451fea6">LL_ADC_REG_SetTriggerEdge</a> (ADC_TypeDef *ADCx, uint32_t ExternalTriggerEdge)</td></tr>
<tr class="memdesc:ga50ae71c40ac2f5ffaf335cb08451fea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion trigger polarity.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga50ae71c40ac2f5ffaf335cb08451fea6">More...</a><br /></td></tr>
<tr class="separator:ga50ae71c40ac2f5ffaf335cb08451fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga8006f5461d8d6a5f16c329e18bffc9e0">LL_ADC_REG_GetTriggerEdge</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion trigger polarity.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga8006f5461d8d6a5f16c329e18bffc9e0">More...</a><br /></td></tr>
<tr class="separator:ga8006f5461d8d6a5f16c329e18bffc9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad2d56f5d16468ef4672cc9d24883a64"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength</a> (ADC_TypeDef *ADCx, uint32_t SequencerNbRanks)</td></tr>
<tr class="memdesc:gaad2d56f5d16468ef4672cc9d24883a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequencer length and scan direction.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaad2d56f5d16468ef4672cc9d24883a64">More...</a><br /></td></tr>
<tr class="separator:gaad2d56f5d16468ef4672cc9d24883a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga0b6cfe92543aae7cb919a0edb2c77846">LL_ADC_REG_GetSequencerLength</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequencer length and scan direction.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga0b6cfe92543aae7cb919a0edb2c77846">More...</a><br /></td></tr>
<tr class="separator:ga0b6cfe92543aae7cb919a0edb2c77846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga12a6e0ce4a5f8cf96c02307bbfa32e48">LL_ADC_REG_SetSequencerDiscont</a> (ADC_TypeDef *ADCx, uint32_t SeqDiscont)</td></tr>
<tr class="memdesc:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga12a6e0ce4a5f8cf96c02307bbfa32e48">More...</a><br /></td></tr>
<tr class="separator:ga12a6e0ce4a5f8cf96c02307bbfa32e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gad88e5a0dfe8f2a9d7c24b379e59d92b3">LL_ADC_REG_GetSequencerDiscont</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. @rmtoll CFGR DISCEN LL_ADC_REG_GetSequencerDiscont<br  />
 CFGR DISCNUM LL_ADC_REG_GetSequencerDiscont.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gad88e5a0dfe8f2a9d7c24b379e59d92b3">More...</a><br /></td></tr>
<tr class="separator:gad88e5a0dfe8f2a9d7c24b379e59d92b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2b090ec6eceed161cd96a04a9debc18"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaa2b090ec6eceed161cd96a04a9debc18">LL_ADC_REG_SetSequencerRanks</a> (ADC_TypeDef *ADCx, uint32_t Rank, uint32_t Channel)</td></tr>
<tr class="memdesc:gaa2b090ec6eceed161cd96a04a9debc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular sequence: channel on the selected scan sequence rank.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaa2b090ec6eceed161cd96a04a9debc18">More...</a><br /></td></tr>
<tr class="separator:gaa2b090ec6eceed161cd96a04a9debc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae7c4a7a145176189253b82c2c923e1a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaae7c4a7a145176189253b82c2c923e1a">LL_ADC_REG_GetSequencerRanks</a> (ADC_TypeDef *ADCx, uint32_t Rank)</td></tr>
<tr class="memdesc:gaae7c4a7a145176189253b82c2c923e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular sequence: channel on the selected scan sequence rank.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaae7c4a7a145176189253b82c2c923e1a">More...</a><br /></td></tr>
<tr class="separator:gaae7c4a7a145176189253b82c2c923e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f66e2c13cc70fec9584f58baf136f34"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga1f66e2c13cc70fec9584f58baf136f34">LL_ADC_REG_SetContinuousMode</a> (ADC_TypeDef *ADCx, uint32_t Continuous)</td></tr>
<tr class="memdesc:ga1f66e2c13cc70fec9584f58baf136f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC continuous conversion mode on ADC group regular.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga1f66e2c13cc70fec9584f58baf136f34">More...</a><br /></td></tr>
<tr class="separator:ga1f66e2c13cc70fec9584f58baf136f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f7af9cc898097474db03c390657c3a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga42f7af9cc898097474db03c390657c3a">LL_ADC_REG_GetContinuousMode</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga42f7af9cc898097474db03c390657c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC continuous conversion mode on ADC group regular.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga42f7af9cc898097474db03c390657c3a">More...</a><br /></td></tr>
<tr class="separator:ga42f7af9cc898097474db03c390657c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b37d974442ef9d415338c3174a7b8e2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga9b37d974442ef9d415338c3174a7b8e2">LL_ADC_REG_SetDMATransfer</a> (ADC_TypeDef *ADCx, uint32_t DMATransfer)</td></tr>
<tr class="memdesc:ga9b37d974442ef9d415338c3174a7b8e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga9b37d974442ef9d415338c3174a7b8e2">More...</a><br /></td></tr>
<tr class="separator:ga9b37d974442ef9d415338c3174a7b8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaa20ef05a5dbd5e22e2c25ab8916c8677">LL_ADC_REG_GetDMATransfer</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaa20ef05a5dbd5e22e2c25ab8916c8677">More...</a><br /></td></tr>
<tr class="separator:gaa20ef05a5dbd5e22e2c25ab8916c8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd3c71269bd469459e9e9baa566b4e90"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gabd3c71269bd469459e9e9baa566b4e90">LL_ADC_REG_SetDFSDMTransfer</a> (ADC_TypeDef *ADCx, uint32_t DFSDMTransfer)</td></tr>
<tr class="memdesc:gabd3c71269bd469459e9e9baa566b4e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular conversion data transfer to DFSDM.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gabd3c71269bd469459e9e9baa566b4e90">More...</a><br /></td></tr>
<tr class="separator:gabd3c71269bd469459e9e9baa566b4e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48cf44120ada31e1ae30f9a8bd4bee32"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga48cf44120ada31e1ae30f9a8bd4bee32">LL_ADC_REG_GetDFSDMTransfer</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga48cf44120ada31e1ae30f9a8bd4bee32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular conversion data transfer to DFSDM. @rmtoll CFGR DFSDMCFG LL_ADC_REG_GetDFSDMTransfer.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga48cf44120ada31e1ae30f9a8bd4bee32">More...</a><br /></td></tr>
<tr class="separator:ga48cf44120ada31e1ae30f9a8bd4bee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0a0fb1797b96bde51ff3bb8d6b5a2b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga8b0a0fb1797b96bde51ff3bb8d6b5a2b">LL_ADC_REG_SetOverrun</a> (ADC_TypeDef *ADCx, uint32_t Overrun)</td></tr>
<tr class="memdesc:ga8b0a0fb1797b96bde51ff3bb8d6b5a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC group regular behavior in case of overrun: data preserved or overwritten.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga8b0a0fb1797b96bde51ff3bb8d6b5a2b">More...</a><br /></td></tr>
<tr class="separator:ga8b0a0fb1797b96bde51ff3bb8d6b5a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a62dd0367667a216bc25ca7dce4d4af"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga0a62dd0367667a216bc25ca7dce4d4af">LL_ADC_REG_GetOverrun</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga0a62dd0367667a216bc25ca7dce4d4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC group regular behavior in case of overrun: data preserved or overwritten. @rmtoll CFGR OVRMOD LL_ADC_REG_GetOverrun.  <a href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga0a62dd0367667a216bc25ca7dce4d4af">More...</a><br /></td></tr>
<tr class="separator:ga0a62dd0367667a216bc25ca7dce4d4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga42f7af9cc898097474db03c390657c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f7af9cc898097474db03c390657c3a">&#9670;&nbsp;</a></span>LL_ADC_REG_GetContinuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetContinuousMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC continuous conversion mode on ADC group regular. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC continuous conversion mode:<ul>
<li>single mode: one conversion per trigger</li>
<li>continuous mode: after the first trigger, following conversions launched successively automatically. @rmtoll CFGR CONT LL_ADC_REG_GetContinuousMode </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_CONV_SINGLE </li>
<li>LL_ADC_REG_CONV_CONTINUOUS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03631">3631</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03632"></a><span class="lineno"> 3632</span>&#160;{</div>
<div class="line"><a name="l03633"></a><span class="lineno"> 3633</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_CONT));</div>
<div class="line"><a name="l03634"></a><span class="lineno"> 3634</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga48cf44120ada31e1ae30f9a8bd4bee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48cf44120ada31e1ae30f9a8bd4bee32">&#9670;&nbsp;</a></span>LL_ADC_REG_GetDFSDMTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetDFSDMTransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion data transfer to DFSDM. @rmtoll CFGR DFSDMCFG LL_ADC_REG_GetDFSDMTransfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_DFSDM_TRANSFER_NONE </li>
<li>LL_ADC_REG_DFSDM_TRANSFER_ENABLE </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03742">3742</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03743"></a><span class="lineno"> 3743</span>&#160;{</div>
<div class="line"><a name="l03744"></a><span class="lineno"> 3744</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_DFSDMCFG));</div>
<div class="line"><a name="l03745"></a><span class="lineno"> 3745</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa20ef05a5dbd5e22e2c25ab8916c8677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa20ef05a5dbd5e22e2c25ab8916c8677">&#9670;&nbsp;</a></span>LL_ADC_REG_GetDMATransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetDMATransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode. </p>
<dl class="section note"><dt>Note</dt><dd>If transfer by DMA selected, specifies the DMA requests mode:<ul>
<li>Limited mode (One shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular.</li>
<li>Unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. </li>
</ul>
</dd>
<dd>
If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transfers size will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error (overrun flag and interruption if enabled). </dd>
<dd>
For devices with several ADC instances: ADC multimode DMA settings are available using function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Multimode.html#ga37bf47182cf5025a73cc1c3c52f575e7">LL_ADC_GetMultiDMATransfer()</a>. </dd>
<dd>
To configure DMA source address (peripheral address), use function <a class="el" href="group__ADC__LL__EF__DMA__Management.html#ga69758b04f38a928fabb87d4e3d40a402">LL_ADC_DMA_GetRegAddr()</a>. @rmtoll CFGR DMAEN LL_ADC_REG_GetDMATransfer<br  />
 CFGR DMACFG LL_ADC_REG_GetDMATransfer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_DMA_TRANSFER_NONE </li>
<li>LL_ADC_REG_DMA_TRANSFER_LIMITED </li>
<li>LL_ADC_REG_DMA_TRANSFER_UNLIMITED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03706">3706</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03707"></a><span class="lineno"> 3707</span>&#160;{</div>
<div class="line"><a name="l03708"></a><span class="lineno"> 3708</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG));</div>
<div class="line"><a name="l03709"></a><span class="lineno"> 3709</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0a62dd0367667a216bc25ca7dce4d4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a62dd0367667a216bc25ca7dce4d4af">&#9670;&nbsp;</a></span>LL_ADC_REG_GetOverrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetOverrun </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular behavior in case of overrun: data preserved or overwritten. @rmtoll CFGR OVRMOD LL_ADC_REG_GetOverrun. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_OVR_DATA_PRESERVED </li>
<li>LL_ADC_REG_OVR_DATA_OVERWRITTEN </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03782">3782</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03783"></a><span class="lineno"> 3783</span>&#160;{</div>
<div class="line"><a name="l03784"></a><span class="lineno"> 3784</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_OVRMOD));</div>
<div class="line"><a name="l03785"></a><span class="lineno"> 3785</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gad88e5a0dfe8f2a9d7c24b379e59d92b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad88e5a0dfe8f2a9d7c24b379e59d92b3">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerDiscont()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerDiscont </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. @rmtoll CFGR DISCEN LL_ADC_REG_GetSequencerDiscont<br  />
 CFGR DISCNUM LL_ADC_REG_GetSequencerDiscont. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_DISCONT_DISABLE </li>
<li>LL_ADC_REG_SEQ_DISCONT_1RANK </li>
<li>LL_ADC_REG_SEQ_DISCONT_2RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_3RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_4RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_5RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_6RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_7RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_8RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03377">3377</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03378"></a><span class="lineno"> 3378</span>&#160;{</div>
<div class="line"><a name="l03379"></a><span class="lineno"> 3379</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM));</div>
<div class="line"><a name="l03380"></a><span class="lineno"> 3380</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga0b6cfe92543aae7cb919a0edb2c77846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b6cfe92543aae7cb919a0edb2c77846">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerLength </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequencer length and scan direction. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC group regular sequencer features:<ul>
<li>For devices with sequencer fully configurable (function "LL_ADC_REG_SetSequencerRanks()" available): sequencer length and each rank affectation to a channel are configurable. This function retrieves:<ul>
<li>Sequence length: Number of ranks in the scan sequence.</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from rank 1 to rank n). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerRanks()".</li>
</ul>
</li>
<li>For devices with sequencer not fully configurable (function "LL_ADC_REG_SetSequencerChannels()" available): sequencer length and each rank affectation to a channel are defined by channel number. This function retrieves:<ul>
<li>Sequence length: Number of ranks in the scan sequence is defined by number of channels set in the sequence, rank of each channel is fixed by channel HW number. (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from lowest channel number to highest channel number). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerChannels()". </li>
</ul>
</li>
</ul>
</dd>
<dd>
Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel. @rmtoll SQR1 L LL_ADC_REG_GetSequencerLength </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_SCAN_DISABLE </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03322">3322</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03323"></a><span class="lineno"> 3323</span>&#160;{</div>
<div class="line"><a name="l03324"></a><span class="lineno"> 3324</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;SQR1, ADC_SQR1_L));</div>
<div class="line"><a name="l03325"></a><span class="lineno"> 3325</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaae7c4a7a145176189253b82c2c923e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae7c4a7a145176189253b82c2c923e1a">&#9670;&nbsp;</a></span>LL_ADC_REG_GetSequencerRanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetSequencerRanks </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular sequence: channel on the selected scan sequence rank. </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, ADC group regular sequencer is fully configurable: sequencer length and each rank affectation to a channel are configurable. Refer to description of function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength()</a>. </dd>
<dd>
Depending on devices and packages, some channels may not be available. Refer to device datasheet for channels availability. </dd>
<dd>
Usage of the returned channel number:<ul>
<li>To reinject this channel into another function LL_ADC_xxx: the returned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be used as parameter for another function.</li>
<li>To get the channel number in decimal format: process the returned value with the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). @rmtoll SQR1 SQ1 LL_ADC_REG_GetSequencerRanks<br  />
 SQR1 SQ2 LL_ADC_REG_GetSequencerRanks<br  />
 SQR1 SQ3 LL_ADC_REG_GetSequencerRanks<br  />
 SQR1 SQ4 LL_ADC_REG_GetSequencerRanks<br  />
 SQR2 SQ5 LL_ADC_REG_GetSequencerRanks<br  />
 SQR2 SQ6 LL_ADC_REG_GetSequencerRanks<br  />
 SQR2 SQ7 LL_ADC_REG_GetSequencerRanks<br  />
 SQR2 SQ8 LL_ADC_REG_GetSequencerRanks<br  />
 SQR2 SQ9 LL_ADC_REG_GetSequencerRanks<br  />
 SQR3 SQ10 LL_ADC_REG_GetSequencerRanks<br  />
 SQR3 SQ11 LL_ADC_REG_GetSequencerRanks<br  />
 SQR3 SQ12 LL_ADC_REG_GetSequencerRanks<br  />
 SQR3 SQ13 LL_ADC_REG_GetSequencerRanks<br  />
 SQR3 SQ14 LL_ADC_REG_GetSequencerRanks<br  />
 SQR4 SQ15 LL_ADC_REG_GetSequencerRanks<br  />
 SQR4 SQ16 LL_ADC_REG_GetSequencerRanks </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Rank</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_RANK_1 </li>
<li>LL_ADC_REG_RANK_2 </li>
<li>LL_ADC_REG_RANK_3 </li>
<li>LL_ADC_REG_RANK_4 </li>
<li>LL_ADC_REG_RANK_5 </li>
<li>LL_ADC_REG_RANK_6 </li>
<li>LL_ADC_REG_RANK_7 </li>
<li>LL_ADC_REG_RANK_8 </li>
<li>LL_ADC_REG_RANK_9 </li>
<li>LL_ADC_REG_RANK_10 </li>
<li>LL_ADC_REG_RANK_11 </li>
<li>LL_ADC_REG_RANK_12 </li>
<li>LL_ADC_REG_RANK_13 </li>
<li>LL_ADC_REG_RANK_14 </li>
<li>LL_ADC_REG_RANK_15 </li>
<li>LL_ADC_REG_RANK_16 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 (7) </li>
<li>LL_ADC_CHANNEL_2 (7) </li>
<li>LL_ADC_CHANNEL_3 (7) </li>
<li>LL_ADC_CHANNEL_4 (7) </li>
<li>LL_ADC_CHANNEL_5 (7) </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (4) </li>
<li>LL_ADC_CHANNEL_VBAT (4) </li>
<li>LL_ADC_CHANNEL_DAC1CH1 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH2 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)</li>
</ul>
(1) On STM32L4, parameter available only on ADC instance: ADC1.<br  />
 (2) On STM32L4, parameter available only on ADC instance: ADC2.<br  />
 (3) On STM32L4, parameter available only on ADC instance: ADC3.<br  />
 (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.<br  />
 (5) On STM32L4, parameter available on devices with only 1 ADC instance.<br  />
 (6) On STM32L4, parameter available on devices with several ADC instances.<br  />
 (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)). Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).<br  />
 (1, 2, 3, 4) For ADC channel read back from ADC register, comparison with internal channel parameter to be done using helper macro __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03585">3585</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03586"></a><span class="lineno"> 3586</span>&#160;{</div>
<div class="line"><a name="l03587"></a><span class="lineno"> 3587</span>&#160;  <span class="keyword">register</span> <span class="keyword">const</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;SQR1, ((Rank &amp; ADC_REG_SQRX_REGOFFSET_MASK) &gt;&gt; ADC_SQRX_REGOFFSET_POS));</div>
<div class="line"><a name="l03588"></a><span class="lineno"> 3588</span>&#160; </div>
<div class="line"><a name="l03589"></a><span class="lineno"> 3589</span>&#160;  <span class="keywordflow">return</span> (uint32_t)((READ_BIT(*preg,</div>
<div class="line"><a name="l03590"></a><span class="lineno"> 3590</span>&#160;                              ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 &lt;&lt; (Rank &amp; ADC_REG_RANK_ID_SQRX_MASK))</div>
<div class="line"><a name="l03591"></a><span class="lineno"> 3591</span>&#160;                     &gt;&gt; (Rank &amp; ADC_REG_RANK_ID_SQRX_MASK)) &lt;&lt; ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS</div>
<div class="line"><a name="l03592"></a><span class="lineno"> 3592</span>&#160;                   );</div>
<div class="line"><a name="l03593"></a><span class="lineno"> 3593</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8006f5461d8d6a5f16c329e18bffc9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8006f5461d8d6a5f16c329e18bffc9e0">&#9670;&nbsp;</a></span>LL_ADC_REG_GetTriggerEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerEdge </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger polarity. </p>
<dl class="section note"><dt>Note</dt><dd>Applicable only for trigger source set to external trigger. @rmtoll CFGR EXTEN LL_ADC_REG_GetTriggerEdge </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_EXT_RISING </li>
<li>LL_ADC_REG_TRIG_EXT_FALLING </li>
<li>LL_ADC_REG_TRIG_EXT_RISINGFALLING </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03209">3209</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03210"></a><span class="lineno"> 3210</span>&#160;{</div>
<div class="line"><a name="l03211"></a><span class="lineno"> 3211</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_EXTEN));</div>
<div class="line"><a name="l03212"></a><span class="lineno"> 3212</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga881dbc8fa2421ca421677fdb4f1a4b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga881dbc8fa2421ca421677fdb4f1a4b6e">&#9670;&nbsp;</a></span>LL_ADC_REG_GetTriggerSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_GetTriggerSource </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line). </p>
<dl class="section note"><dt>Note</dt><dd>To determine whether group regular trigger source is internal (SW start) or external, without detail of which peripheral is selected as external trigger, (equivalent to "if(LL_ADC_REG_GetTriggerSource(ADC1) == LL_ADC_REG_TRIG_SOFTWARE)") use function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaaa50f143fbbb1df8671053e1a7aec8c3">LL_ADC_REG_IsTriggerSourceSWStart</a>. </dd>
<dd>
Availability of parameters of trigger sources from timer depends on timers availability on the selected device. @rmtoll CFGR EXTSEL LL_ADC_REG_GetTriggerSource<br  />
 CFGR EXTEN LL_ADC_REG_GetTriggerSource </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_SOFTWARE </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_TRGO2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM6_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM15_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_EXTI_LINE11 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03147">3147</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03148"></a><span class="lineno"> 3148</span>&#160;{</div>
<div class="line"><a name="l03149"></a><span class="lineno"> 3149</span>&#160;  <span class="keyword">register</span> __IO uint32_t TriggerSource = READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_EXTSEL | ADC_CFGR_EXTEN);</div>
<div class="line"><a name="l03150"></a><span class="lineno"> 3150</span>&#160; </div>
<div class="line"><a name="l03151"></a><span class="lineno"> 3151</span>&#160;  <span class="comment">/* Value for shift of {0; 4; 8; 12} depending on value of bitfield          */</span></div>
<div class="line"><a name="l03152"></a><span class="lineno"> 3152</span>&#160;  <span class="comment">/* corresponding to ADC_CFGR_EXTEN {0; 1; 2; 3}.                            */</span></div>
<div class="line"><a name="l03153"></a><span class="lineno"> 3153</span>&#160;  <span class="keyword">register</span> uint32_t ShiftExten = ((TriggerSource &amp; ADC_CFGR_EXTEN) &gt;&gt; (ADC_REG_TRIG_EXTEN_BITOFFSET_POS - 2UL));</div>
<div class="line"><a name="l03154"></a><span class="lineno"> 3154</span>&#160; </div>
<div class="line"><a name="l03155"></a><span class="lineno"> 3155</span>&#160;  <span class="comment">/* Set bitfield corresponding to ADC_CFGR_EXTEN and ADC_CFGR_EXTSEL         */</span></div>
<div class="line"><a name="l03156"></a><span class="lineno"> 3156</span>&#160;  <span class="comment">/* to match with triggers literals definition.                              */</span></div>
<div class="line"><a name="l03157"></a><span class="lineno"> 3157</span>&#160;  <span class="keywordflow">return</span> ((TriggerSource</div>
<div class="line"><a name="l03158"></a><span class="lineno"> 3158</span>&#160;           &amp; (ADC_REG_TRIG_SOURCE_MASK &gt;&gt; ShiftExten) &amp; ADC_CFGR_EXTSEL)</div>
<div class="line"><a name="l03159"></a><span class="lineno"> 3159</span>&#160;          | ((ADC_REG_TRIG_EDGE_MASK &gt;&gt; ShiftExten) &amp; ADC_CFGR_EXTEN)</div>
<div class="line"><a name="l03160"></a><span class="lineno"> 3160</span>&#160;         );</div>
<div class="line"><a name="l03161"></a><span class="lineno"> 3161</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaaa50f143fbbb1df8671053e1a7aec8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa50f143fbbb1df8671053e1a7aec8c3">&#9670;&nbsp;</a></span>LL_ADC_REG_IsTriggerSourceSWStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_REG_IsTriggerSourceSWStart </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC group regular conversion trigger source internal (SW start) or external. </p>
<dl class="section note"><dt>Note</dt><dd>In case of group regular trigger source set to external trigger, to determine which peripheral is selected as external trigger, use function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga881dbc8fa2421ca421677fdb4f1a4b6e">LL_ADC_REG_GetTriggerSource()</a>. @rmtoll CFGR EXTEN LL_ADC_REG_IsTriggerSourceSWStart </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>"0" if trigger source external trigger Value "1" if trigger source SW start. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03174">3174</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03175"></a><span class="lineno"> 3175</span>&#160;{</div>
<div class="line"><a name="l03176"></a><span class="lineno"> 3176</span>&#160;  <span class="keywordflow">return</span> ((READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_EXTEN) == (LL_ADC_REG_TRIG_SOFTWARE &amp; ADC_CFGR_EXTEN)) ? 1UL : 0UL);</div>
<div class="line"><a name="l03177"></a><span class="lineno"> 3177</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga1f66e2c13cc70fec9584f58baf136f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f66e2c13cc70fec9584f58baf136f34">&#9670;&nbsp;</a></span>LL_ADC_REG_SetContinuousMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetContinuousMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Continuous</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC continuous conversion mode on ADC group regular. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC continuous conversion mode:<ul>
<li>single mode: one conversion per trigger</li>
<li>continuous mode: after the first trigger, following conversions launched successively automatically. </li>
</ul>
</dd>
<dd>
It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll CFGR CONT LL_ADC_REG_SetContinuousMode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Continuous</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_CONV_SINGLE </li>
<li>LL_ADC_REG_CONV_CONTINUOUS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03614">3614</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03615"></a><span class="lineno"> 3615</span>&#160;{</div>
<div class="line"><a name="l03616"></a><span class="lineno"> 3616</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_CONT, Continuous);</div>
<div class="line"><a name="l03617"></a><span class="lineno"> 3617</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gabd3c71269bd469459e9e9baa566b4e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd3c71269bd469459e9e9baa566b4e90">&#9670;&nbsp;</a></span>LL_ADC_REG_SetDFSDMTransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetDFSDMTransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>DFSDMTransfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion data transfer to DFSDM. </p>
<dl class="section note"><dt>Note</dt><dd>DFSDM transfer cannot be used if DMA transfer is enabled. </dd>
<dd>
To configure DFSDM source address (peripheral address), use the same function as for DMA transfer: function <a class="el" href="group__ADC__LL__EF__DMA__Management.html#ga69758b04f38a928fabb87d4e3d40a402">LL_ADC_DMA_GetRegAddr()</a>. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll CFGR DFSDMCFG LL_ADC_REG_GetDFSDMTransfer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">DFSDMTransfer</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_DFSDM_TRANSFER_NONE </li>
<li>LL_ADC_REG_DFSDM_TRANSFER_ENABLE </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03729">3729</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03730"></a><span class="lineno"> 3730</span>&#160;{</div>
<div class="line"><a name="l03731"></a><span class="lineno"> 3731</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_DFSDMCFG, DFSDMTransfer);</div>
<div class="line"><a name="l03732"></a><span class="lineno"> 3732</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9b37d974442ef9d415338c3174a7b8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b37d974442ef9d415338c3174a7b8e2">&#9670;&nbsp;</a></span>LL_ADC_REG_SetDMATransfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetDMATransfer </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>DMATransfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion data transfer: no transfer or transfer by DMA, and DMA requests mode. </p>
<dl class="section note"><dt>Note</dt><dd>If transfer by DMA selected, specifies the DMA requests mode:<ul>
<li>Limited mode (One shot mode): DMA transfer requests are stopped when number of DMA data transfers (number of ADC conversions) is reached. This ADC mode is intended to be used with DMA mode non-circular.</li>
<li>Unlimited mode: DMA transfer requests are unlimited, whatever number of DMA data transfers (number of ADC conversions). This ADC mode is intended to be used with DMA mode circular. </li>
</ul>
</dd>
<dd>
If ADC DMA requests mode is set to unlimited and DMA is set to mode non-circular: when DMA transfers size will be reached, DMA will stop transfers of ADC conversions data ADC will raise an overrun error (overrun flag and interruption if enabled). </dd>
<dd>
For devices with several ADC instances: ADC multimode DMA settings are available using function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Multimode.html#ga0631b2706225ab48fc166f6ae21156be">LL_ADC_SetMultiDMATransfer()</a>. </dd>
<dd>
To configure DMA source address (peripheral address), use function <a class="el" href="group__ADC__LL__EF__DMA__Management.html#ga69758b04f38a928fabb87d4e3d40a402">LL_ADC_DMA_GetRegAddr()</a>. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll CFGR DMAEN LL_ADC_REG_SetDMATransfer<br  />
 CFGR DMACFG LL_ADC_REG_SetDMATransfer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">DMATransfer</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_DMA_TRANSFER_NONE </li>
<li>LL_ADC_REG_DMA_TRANSFER_LIMITED </li>
<li>LL_ADC_REG_DMA_TRANSFER_UNLIMITED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03671">3671</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03672"></a><span class="lineno"> 3672</span>&#160;{</div>
<div class="line"><a name="l03673"></a><span class="lineno"> 3673</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_DMAEN | ADC_CFGR_DMACFG, DMATransfer);</div>
<div class="line"><a name="l03674"></a><span class="lineno"> 3674</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8b0a0fb1797b96bde51ff3bb8d6b5a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b0a0fb1797b96bde51ff3bb8d6b5a2b">&#9670;&nbsp;</a></span>LL_ADC_REG_SetOverrun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetOverrun </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Overrun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular behavior in case of overrun: data preserved or overwritten. </p>
<dl class="section note"><dt>Note</dt><dd>Compatibility with devices without feature overrun: other devices without this feature have a behavior equivalent to data overwritten. The default setting of overrun is data preserved. Therefore, for compatibility with all devices, parameter overrun should be set to data overwritten. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll CFGR OVRMOD LL_ADC_REG_SetOverrun </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Overrun</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_OVR_DATA_PRESERVED </li>
<li>LL_ADC_REG_OVR_DATA_OVERWRITTEN </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03768">3768</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03769"></a><span class="lineno"> 3769</span>&#160;{</div>
<div class="line"><a name="l03770"></a><span class="lineno"> 3770</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_OVRMOD, Overrun);</div>
<div class="line"><a name="l03771"></a><span class="lineno"> 3771</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga12a6e0ce4a5f8cf96c02307bbfa32e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12a6e0ce4a5f8cf96c02307bbfa32e48">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerDiscont()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerDiscont </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SeqDiscont</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequencer discontinuous mode: sequence subdivided and scan conversions interrupted every selected number of ranks. </p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to enable both ADC group regular continuous mode and sequencer discontinuous mode. </dd>
<dd>
It is not possible to enable both ADC auto-injected mode and ADC group regular sequencer discontinuous mode. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll CFGR DISCEN LL_ADC_REG_SetSequencerDiscont<br  />
 CFGR DISCNUM LL_ADC_REG_SetSequencerDiscont </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SeqDiscont</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_DISCONT_DISABLE </li>
<li>LL_ADC_REG_SEQ_DISCONT_1RANK </li>
<li>LL_ADC_REG_SEQ_DISCONT_2RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_3RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_4RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_5RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_6RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_7RANKS </li>
<li>LL_ADC_REG_SEQ_DISCONT_8RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03354">3354</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03355"></a><span class="lineno"> 3355</span>&#160;{</div>
<div class="line"><a name="l03356"></a><span class="lineno"> 3356</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_DISCEN | ADC_CFGR_DISCNUM, SeqDiscont);</div>
<div class="line"><a name="l03357"></a><span class="lineno"> 3357</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaad2d56f5d16468ef4672cc9d24883a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad2d56f5d16468ef4672cc9d24883a64">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerLength </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SequencerNbRanks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequencer length and scan direction. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC group regular sequencer features:<ul>
<li>For devices with sequencer fully configurable (function "LL_ADC_REG_SetSequencerRanks()" available): sequencer length and each rank affectation to a channel are configurable. This function performs configuration of:<ul>
<li>Sequence length: Number of ranks in the scan sequence.</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from rank 1 to rank n). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerRanks()".</li>
</ul>
</li>
<li>For devices with sequencer not fully configurable (function "LL_ADC_REG_SetSequencerChannels()" available): sequencer length and each rank affectation to a channel are defined by channel number. This function performs configuration of:<ul>
<li>Sequence length: Number of ranks in the scan sequence is defined by number of channels set in the sequence, rank of each channel is fixed by channel HW number. (channel 0 fixed on rank 0, channel 1 fixed on rank1, ...).</li>
<li>Sequence direction: Unless specified in parameters, sequencer scan direction is forward (from lowest channel number to highest channel number). Sequencer ranks are selected using function "LL_ADC_REG_SetSequencerChannels()". </li>
</ul>
</li>
</ul>
</dd>
<dd>
Sequencer disabled is equivalent to sequencer of 1 rank: ADC conversion on only 1 channel. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll SQR1 L LL_ADC_REG_SetSequencerLength </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SequencerNbRanks</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_SEQ_SCAN_DISABLE </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_2RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_3RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_4RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_5RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_6RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_7RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_8RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_9RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_10RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_11RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_12RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_13RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_14RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_15RANKS </li>
<li>LL_ADC_REG_SEQ_SCAN_ENABLE_16RANKS </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03268">3268</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03269"></a><span class="lineno"> 3269</span>&#160;{</div>
<div class="line"><a name="l03270"></a><span class="lineno"> 3270</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;SQR1, ADC_SQR1_L, SequencerNbRanks);</div>
<div class="line"><a name="l03271"></a><span class="lineno"> 3271</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa2b090ec6eceed161cd96a04a9debc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2b090ec6eceed161cd96a04a9debc18">&#9670;&nbsp;</a></span>LL_ADC_REG_SetSequencerRanks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetSequencerRanks </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular sequence: channel on the selected scan sequence rank. </p>
<dl class="section note"><dt>Note</dt><dd>This function performs configuration of:<ul>
<li>Channels ordering into each rank of scan sequence: whatever channel can be placed into whatever rank. </li>
</ul>
</dd>
<dd>
On this STM32 serie, ADC group regular sequencer is fully configurable: sequencer length and each rank affectation to a channel are configurable. Refer to description of function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#gaad2d56f5d16468ef4672cc9d24883a64">LL_ADC_REG_SetSequencerLength()</a>. </dd>
<dd>
Depending on devices and packages, some channels may not be available. Refer to device datasheet for channels availability. </dd>
<dd>
On this STM32 serie, to measure internal channels (VrefInt, TempSensor, ...), measurement paths to internal channels must be enabled separately. This can be done using function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Common.html#gada4e99bea81f03d942d2f6d51b360154">LL_ADC_SetCommonPathInternalCh()</a>. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll SQR1 SQ1 LL_ADC_REG_SetSequencerRanks<br  />
 SQR1 SQ2 LL_ADC_REG_SetSequencerRanks<br  />
 SQR1 SQ3 LL_ADC_REG_SetSequencerRanks<br  />
 SQR1 SQ4 LL_ADC_REG_SetSequencerRanks<br  />
 SQR2 SQ5 LL_ADC_REG_SetSequencerRanks<br  />
 SQR2 SQ6 LL_ADC_REG_SetSequencerRanks<br  />
 SQR2 SQ7 LL_ADC_REG_SetSequencerRanks<br  />
 SQR2 SQ8 LL_ADC_REG_SetSequencerRanks<br  />
 SQR2 SQ9 LL_ADC_REG_SetSequencerRanks<br  />
 SQR3 SQ10 LL_ADC_REG_SetSequencerRanks<br  />
 SQR3 SQ11 LL_ADC_REG_SetSequencerRanks<br  />
 SQR3 SQ12 LL_ADC_REG_SetSequencerRanks<br  />
 SQR3 SQ13 LL_ADC_REG_SetSequencerRanks<br  />
 SQR3 SQ14 LL_ADC_REG_SetSequencerRanks<br  />
 SQR4 SQ15 LL_ADC_REG_SetSequencerRanks<br  />
 SQR4 SQ16 LL_ADC_REG_SetSequencerRanks </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Rank</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_RANK_1 </li>
<li>LL_ADC_REG_RANK_2 </li>
<li>LL_ADC_REG_RANK_3 </li>
<li>LL_ADC_REG_RANK_4 </li>
<li>LL_ADC_REG_RANK_5 </li>
<li>LL_ADC_REG_RANK_6 </li>
<li>LL_ADC_REG_RANK_7 </li>
<li>LL_ADC_REG_RANK_8 </li>
<li>LL_ADC_REG_RANK_9 </li>
<li>LL_ADC_REG_RANK_10 </li>
<li>LL_ADC_REG_RANK_11 </li>
<li>LL_ADC_REG_RANK_12 </li>
<li>LL_ADC_REG_RANK_13 </li>
<li>LL_ADC_REG_RANK_14 </li>
<li>LL_ADC_REG_RANK_15 </li>
<li>LL_ADC_REG_RANK_16 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Channel</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 (7) </li>
<li>LL_ADC_CHANNEL_2 (7) </li>
<li>LL_ADC_CHANNEL_3 (7) </li>
<li>LL_ADC_CHANNEL_4 (7) </li>
<li>LL_ADC_CHANNEL_5 (7) </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (4) </li>
<li>LL_ADC_CHANNEL_VBAT (4) </li>
<li>LL_ADC_CHANNEL_DAC1CH1 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH2 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)</li>
</ul>
(1) On STM32L4, parameter available only on ADC instance: ADC1.<br  />
 (2) On STM32L4, parameter available only on ADC instance: ADC2.<br  />
 (3) On STM32L4, parameter available only on ADC instance: ADC3.<br  />
 (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.<br  />
 (5) On STM32L4, parameter available on devices with only 1 ADC instance.<br  />
 (6) On STM32L4, parameter available on devices with several ADC instances.<br  />
 (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)). Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03476">3476</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03477"></a><span class="lineno"> 3477</span>&#160;{</div>
<div class="line"><a name="l03478"></a><span class="lineno"> 3478</span>&#160;  <span class="comment">/* Set bits with content of parameter &quot;Channel&quot; with bits position          */</span></div>
<div class="line"><a name="l03479"></a><span class="lineno"> 3479</span>&#160;  <span class="comment">/* in register and register position depending on parameter &quot;Rank&quot;.         */</span></div>
<div class="line"><a name="l03480"></a><span class="lineno"> 3480</span>&#160;  <span class="comment">/* Parameters &quot;Rank&quot; and &quot;Channel&quot; are used with masks because containing   */</span></div>
<div class="line"><a name="l03481"></a><span class="lineno"> 3481</span>&#160;  <span class="comment">/* other bits reserved for other purpose.                                   */</span></div>
<div class="line"><a name="l03482"></a><span class="lineno"> 3482</span>&#160;  <span class="keyword">register</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;SQR1, ((Rank &amp; ADC_REG_SQRX_REGOFFSET_MASK) &gt;&gt; ADC_SQRX_REGOFFSET_POS));</div>
<div class="line"><a name="l03483"></a><span class="lineno"> 3483</span>&#160; </div>
<div class="line"><a name="l03484"></a><span class="lineno"> 3484</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(*preg,</div>
<div class="line"><a name="l03485"></a><span class="lineno"> 3485</span>&#160;             ADC_CHANNEL_ID_NUMBER_MASK_POSBIT0 &lt;&lt; (Rank &amp; ADC_REG_RANK_ID_SQRX_MASK),</div>
<div class="line"><a name="l03486"></a><span class="lineno"> 3486</span>&#160;             ((Channel &amp; ADC_CHANNEL_ID_NUMBER_MASK) &gt;&gt; ADC_CHANNEL_ID_NUMBER_BITOFFSET_POS) &lt;&lt; (Rank &amp; ADC_REG_RANK_ID_SQRX_MASK));</div>
<div class="line"><a name="l03487"></a><span class="lineno"> 3487</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga50ae71c40ac2f5ffaf335cb08451fea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50ae71c40ac2f5ffaf335cb08451fea6">&#9670;&nbsp;</a></span>LL_ADC_REG_SetTriggerEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetTriggerEdge </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ExternalTriggerEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion trigger polarity. </p>
<dl class="section note"><dt>Note</dt><dd>Applicable only for trigger source set to external trigger. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll CFGR EXTEN LL_ADC_REG_SetTriggerEdge </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">ExternalTriggerEdge</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_EXT_RISING </li>
<li>LL_ADC_REG_TRIG_EXT_FALLING </li>
<li>LL_ADC_REG_TRIG_EXT_RISINGFALLING </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03194">3194</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03195"></a><span class="lineno"> 3195</span>&#160;{</div>
<div class="line"><a name="l03196"></a><span class="lineno"> 3196</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_EXTEN, ExternalTriggerEdge);</div>
<div class="line"><a name="l03197"></a><span class="lineno"> 3197</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga46331bb05afe971e9ad6b54efd5f07ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46331bb05afe971e9ad6b54efd5f07ee">&#9670;&nbsp;</a></span>LL_ADC_REG_SetTriggerSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_REG_SetTriggerSource </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>TriggerSource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC group regular conversion trigger source: internal (SW start) or from external peripheral (timer event, external interrupt line). </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, setting trigger source to external trigger also set trigger polarity to rising edge (default setting for compatibility with some ADC on other STM32 families having this setting set by HW default value). In case of need to modify trigger edge, use function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Group__Regular.html#ga50ae71c40ac2f5ffaf335cb08451fea6">LL_ADC_REG_SetTriggerEdge()</a>. </dd>
<dd>
Availability of parameters of trigger sources from timer depends on timers availability on the selected device. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on group regular. @rmtoll CFGR EXTSEL LL_ADC_REG_SetTriggerSource<br  />
 CFGR EXTEN LL_ADC_REG_SetTriggerSource </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">TriggerSource</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_REG_TRIG_SOFTWARE </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_TRGO2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH1 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM1_CH3 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM2_CH2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM3_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM4_CH4 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM6_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_TIM8_TRGO2 </li>
<li>LL_ADC_REG_TRIG_EXT_TIM15_TRGO </li>
<li>LL_ADC_REG_TRIG_EXT_EXTI_LINE11 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03108">3108</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03109"></a><span class="lineno"> 3109</span>&#160;{</div>
<div class="line"><a name="l03110"></a><span class="lineno"> 3110</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_EXTEN | ADC_CFGR_EXTSEL, TriggerSource);</div>
<div class="line"><a name="l03111"></a><span class="lineno"> 3111</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__RTCEx__Exported__Functions__Group2_html_gaf0bea6a9989d50f8ffa9b2afc911fc4b"><div class="ttname"><a href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a></div><div class="ttdeci">MODIFY_REG(hrtc-&gt;Instance-&gt;CR, RTC_CR_WUCKSEL,(uint32_t) WakeUpClock)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
