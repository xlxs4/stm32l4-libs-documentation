<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>STM32L4xx_HAL_Driver: Configuration of ADC hierarchical scope: ADC instance</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">STM32L4xx_HAL_Driver
   &#160;<span id="projectnumber">1.14.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__ADC__LL__EF__Configuration__ADC__Instance.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Configuration of ADC hierarchical scope: ADC instance<div class="ingroups"><a class="el" href="group__STM32L4xx__LL__Driver.html">STM32L4xx_LL_Driver</a> &raquo; <a class="el" href="group__ADC__LL.html">ADC</a> &raquo; <a class="el" href="group__ADC__LL__Exported__Functions.html">ADC Exported Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga824344d3c7ce755028ee08d47db919ef"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga824344d3c7ce755028ee08d47db919ef">LL_ADC_SetCalibrationFactor</a> (ADC_TypeDef *ADCx, uint32_t SingleDiff, uint32_t CalibrationFactor)</td></tr>
<tr class="memdesc:ga824344d3c7ce755028ee08d47db919ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC calibration factor in the mode single-ended or differential (for devices with differential mode available).  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga824344d3c7ce755028ee08d47db919ef">More...</a><br /></td></tr>
<tr class="separator:ga824344d3c7ce755028ee08d47db919ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1e8198d04a388cc4d8dfea8e8108daa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gad1e8198d04a388cc4d8dfea8e8108daa">LL_ADC_GetCalibrationFactor</a> (ADC_TypeDef *ADCx, uint32_t SingleDiff)</td></tr>
<tr class="memdesc:gad1e8198d04a388cc4d8dfea8e8108daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC calibration factor in the mode single-ended or differential (for devices with differential mode available).  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gad1e8198d04a388cc4d8dfea8e8108daa">More...</a><br /></td></tr>
<tr class="separator:gad1e8198d04a388cc4d8dfea8e8108daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b46d0fa39d1ea30f8e20a596f48e2e3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga9b46d0fa39d1ea30f8e20a596f48e2e3">LL_ADC_SetResolution</a> (ADC_TypeDef *ADCx, uint32_t Resolution)</td></tr>
<tr class="memdesc:ga9b46d0fa39d1ea30f8e20a596f48e2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC resolution. Refer to reference manual for alignments formats dependencies to ADC resolutions.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga9b46d0fa39d1ea30f8e20a596f48e2e3">More...</a><br /></td></tr>
<tr class="separator:ga9b46d0fa39d1ea30f8e20a596f48e2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga343cabf2e971a2274d2d66117ca5d857"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga343cabf2e971a2274d2d66117ca5d857">LL_ADC_GetResolution</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga343cabf2e971a2274d2d66117ca5d857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC resolution. Refer to reference manual for alignments formats dependencies to ADC resolutions. @rmtoll CFGR RES LL_ADC_GetResolution.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga343cabf2e971a2274d2d66117ca5d857">More...</a><br /></td></tr>
<tr class="separator:ga343cabf2e971a2274d2d66117ca5d857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6b8586d5462e96b4d55b66f1444d69c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaf6b8586d5462e96b4d55b66f1444d69c">LL_ADC_SetDataAlignment</a> (ADC_TypeDef *ADCx, uint32_t DataAlignment)</td></tr>
<tr class="memdesc:gaf6b8586d5462e96b4d55b66f1444d69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC conversion data alignment.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaf6b8586d5462e96b4d55b66f1444d69c">More...</a><br /></td></tr>
<tr class="separator:gaf6b8586d5462e96b4d55b66f1444d69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c79127b2eb78e83332defc8786be214"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga2c79127b2eb78e83332defc8786be214">LL_ADC_GetDataAlignment</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga2c79127b2eb78e83332defc8786be214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC conversion data alignment.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga2c79127b2eb78e83332defc8786be214">More...</a><br /></td></tr>
<tr class="separator:ga2c79127b2eb78e83332defc8786be214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4d82777c28b1031b961ad1cdb0af174"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa4d82777c28b1031b961ad1cdb0af174">LL_ADC_SetLowPowerMode</a> (ADC_TypeDef *ADCx, uint32_t LowPowerMode)</td></tr>
<tr class="memdesc:gaa4d82777c28b1031b961ad1cdb0af174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC low power mode.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa4d82777c28b1031b961ad1cdb0af174">More...</a><br /></td></tr>
<tr class="separator:gaa4d82777c28b1031b961ad1cdb0af174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga854760d1bb76b1caccb83c4821983a2c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga854760d1bb76b1caccb83c4821983a2c">LL_ADC_GetLowPowerMode</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:ga854760d1bb76b1caccb83c4821983a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC low power mode:  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga854760d1bb76b1caccb83c4821983a2c">More...</a><br /></td></tr>
<tr class="separator:ga854760d1bb76b1caccb83c4821983a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ce2d283f23c049109b92f44c593a54d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga2ce2d283f23c049109b92f44c593a54d">LL_ADC_SetOffset</a> (ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t Channel, uint32_t OffsetLevel)</td></tr>
<tr class="memdesc:ga2ce2d283f23c049109b92f44c593a54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC selected offset number 1, 2, 3 or 4.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga2ce2d283f23c049109b92f44c593a54d">More...</a><br /></td></tr>
<tr class="separator:ga2ce2d283f23c049109b92f44c593a54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa146cb812758b299eb03d402a7543749"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa146cb812758b299eb03d402a7543749">LL_ADC_GetOffsetChannel</a> (ADC_TypeDef *ADCx, uint32_t Offsety)</td></tr>
<tr class="memdesc:gaa146cb812758b299eb03d402a7543749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get for the ADC selected offset number 1, 2, 3 or 4: Channel to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected)  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa146cb812758b299eb03d402a7543749">More...</a><br /></td></tr>
<tr class="separator:gaa146cb812758b299eb03d402a7543749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade4feec0ff65eefcbabcc922db8907ed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gade4feec0ff65eefcbabcc922db8907ed">LL_ADC_GetOffsetLevel</a> (ADC_TypeDef *ADCx, uint32_t Offsety)</td></tr>
<tr class="memdesc:gade4feec0ff65eefcbabcc922db8907ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get for the ADC selected offset number 1, 2, 3 or 4: Offset level (offset to be subtracted from the raw converted data).  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gade4feec0ff65eefcbabcc922db8907ed">More...</a><br /></td></tr>
<tr class="separator:gade4feec0ff65eefcbabcc922db8907ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2fc70a0921b99d1180ae9f0e6448fc2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gac2fc70a0921b99d1180ae9f0e6448fc2">LL_ADC_SetOffsetState</a> (ADC_TypeDef *ADCx, uint32_t Offsety, uint32_t OffsetState)</td></tr>
<tr class="memdesc:gac2fc70a0921b99d1180ae9f0e6448fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set for the ADC selected offset number 1, 2, 3 or 4: force offset state disable or enable without modifying offset channel or offset value.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gac2fc70a0921b99d1180ae9f0e6448fc2">More...</a><br /></td></tr>
<tr class="separator:gac2fc70a0921b99d1180ae9f0e6448fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae94a9e185e543ed623c65e6e5f20e5ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gae94a9e185e543ed623c65e6e5f20e5ba">LL_ADC_GetOffsetState</a> (ADC_TypeDef *ADCx, uint32_t Offsety)</td></tr>
<tr class="memdesc:gae94a9e185e543ed623c65e6e5f20e5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get for the ADC selected offset number 1, 2, 3 or 4: offset state disabled or enabled. @rmtoll OFR1 OFFSET1_EN LL_ADC_GetOffsetState<br  />
 OFR2 OFFSET2_EN LL_ADC_GetOffsetState<br  />
 OFR3 OFFSET3_EN LL_ADC_GetOffsetState<br  />
 OFR4 OFFSET4_EN LL_ADC_GetOffsetState.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gae94a9e185e543ed623c65e6e5f20e5ba">More...</a><br /></td></tr>
<tr class="separator:gae94a9e185e543ed623c65e6e5f20e5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22c65073526025e556237cc897e71d9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa22c65073526025e556237cc897e71d9">LL_ADC_SetSamplingTimeCommonConfig</a> (ADC_TypeDef *ADCx, uint32_t SamplingTimeCommonConfig)</td></tr>
<tr class="memdesc:gaa22c65073526025e556237cc897e71d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set ADC sampling time common configuration impacting settings of sampling time channel wise.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaa22c65073526025e556237cc897e71d9">More...</a><br /></td></tr>
<tr class="separator:gaa22c65073526025e556237cc897e71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9ae1e7bd9f990def1799ec4824ebaef"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaf9ae1e7bd9f990def1799ec4824ebaef">LL_ADC_GetSamplingTimeCommonConfig</a> (ADC_TypeDef *ADCx)</td></tr>
<tr class="memdesc:gaf9ae1e7bd9f990def1799ec4824ebaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ADC sampling time common configuration impacting settings of sampling time channel wise. @rmtoll SMPR1 SMPPLUS LL_ADC_GetSamplingTimeCommonConfig.  <a href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gaf9ae1e7bd9f990def1799ec4824ebaef">More...</a><br /></td></tr>
<tr class="separator:gaf9ae1e7bd9f990def1799ec4824ebaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad1e8198d04a388cc4d8dfea8e8108daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1e8198d04a388cc4d8dfea8e8108daa">&#9670;&nbsp;</a></span>LL_ADC_GetCalibrationFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetCalibrationFactor </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SingleDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC calibration factor in the mode single-ended or differential (for devices with differential mode available). </p>
<dl class="section note"><dt>Note</dt><dd>Calibration factors are set by hardware after performing a calibration run using function <a class="el" href="group__ADC__LL__EF__Operation__ADC__Instance.html#ga0ec7b7d7c4207b4f36121d82bfe3a9e0">LL_ADC_StartCalibration()</a>. </dd>
<dd>
For devices with differential mode available: Calibration of offset is specific to each of single-ended and differential modes @rmtoll CALFACT CALFACT_S LL_ADC_GetCalibrationFactor<br  />
 CALFACT CALFACT_D LL_ADC_GetCalibrationFactor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SingleDiff</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_SINGLE_ENDED </li>
<li>LL_ADC_DIFFERENTIAL_ENDED </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between Min_Data=0x00 and Max_Data=0x7F </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02591">2591</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;{</div>
<div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;  <span class="comment">/* Retrieve bits with position in register depending on parameter           */</span></div>
<div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;  <span class="comment">/* &quot;SingleDiff&quot;.                                                            */</span></div>
<div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;  <span class="comment">/* Parameter used with mask &quot;ADC_SINGLEDIFF_CALIB_FACTOR_MASK&quot; because      */</span></div>
<div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;  <span class="comment">/* containing other bits reserved for other purpose.                        */</span></div>
<div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CALFACT, (SingleDiff &amp; ADC_SINGLEDIFF_CALIB_FACTOR_MASK)) &gt;&gt; ((SingleDiff &amp; ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK) &gt;&gt; ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4));</div>
<div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2c79127b2eb78e83332defc8786be214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c79127b2eb78e83332defc8786be214">&#9670;&nbsp;</a></span>LL_ADC_GetDataAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetDataAlignment </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC conversion data alignment. </p>
<dl class="section note"><dt>Note</dt><dd>Refer to reference manual for alignments formats dependencies to ADC resolutions. @rmtoll CFGR ALIGN LL_ADC_GetDataAlignment </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_DATA_ALIGN_RIGHT </li>
<li>LL_ADC_DATA_ALIGN_LEFT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02669">2669</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;{</div>
<div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_ALIGN));</div>
<div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga854760d1bb76b1caccb83c4821983a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga854760d1bb76b1caccb83c4821983a2c">&#9670;&nbsp;</a></span>LL_ADC_GetLowPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetLowPowerMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC low power mode: </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC low power modes:<ul>
<li>ADC low power mode "auto wait": Dynamic low power mode, ADC conversions occurrences are limited to the minimum necessary in order to reduce power consumption. New ADC conversion starts only when the previous unitary conversion data (for ADC group regular) or previous sequence conversions data (for ADC group injected) has been retrieved by user software. In the meantime, ADC remains idle: does not performs any other conversion. This mode allows to automatically adapt the ADC conversions triggers to the speed of the software that reads the data. Moreover, this avoids risk of overrun for low frequency applications. How to use this low power mode:<ul>
<li>Do not use with interruption or DMA since these modes have to clear immediately the EOC flag to free the IRQ vector sequencer.</li>
<li>Do use with polling: 1. Start conversion,<ol type="1">
<li>Later on, when conversion data is needed: poll for end of conversion to ensure that conversion is completed and retrieve ADC conversion data. This will trig another ADC conversion start.</li>
</ol>
</li>
</ul>
</li>
<li>ADC low power mode "auto power-off" (feature available on this device if parameter LL_ADC_LP_AUTOPOWEROFF is available): the ADC automatically powers-off after a conversion and automatically wakes up when a new conversion is triggered (with startup time between trigger and start of sampling). This feature can be combined with low power mode "auto wait". </li>
</ul>
</dd>
<dd>
With ADC low power mode "auto wait", the ADC conversion data read is corresponding to previous ADC conversion start, independently of delay during which ADC was idle. Therefore, the ADC conversion data may be outdated: does not correspond to the current voltage level on the selected ADC channel. @rmtoll CFGR AUTDLY LL_ADC_GetLowPowerMode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_LP_MODE_NONE </li>
<li>LL_ADC_LP_AUTOWAIT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02770">2770</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;{</div>
<div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_AUTDLY));</div>
<div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa146cb812758b299eb03d402a7543749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa146cb812758b299eb03d402a7543749">&#9670;&nbsp;</a></span>LL_ADC_GetOffsetChannel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetOffsetChannel </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Offsety</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get for the ADC selected offset number 1, 2, 3 or 4: Channel to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected) </p>
<dl class="section note"><dt>Note</dt><dd>Usage of the returned channel number:<ul>
<li>To reinject this channel into another function LL_ADC_xxx: the returned channel number is only partly formatted on definition of literals LL_ADC_CHANNEL_x. Therefore, it has to be compared with parts of literals LL_ADC_CHANNEL_x or using helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). Then the selected literal LL_ADC_CHANNEL_x can be used as parameter for another function.</li>
<li>To get the channel number in decimal format: process the returned value with the helper macro __LL_ADC_CHANNEL_TO_DECIMAL_NB(). </li>
</ul>
</dd>
<dd>
On STM32L4, some fast channels are available: fast analog inputs coming from GPIO pads (ADC_IN1..5). @rmtoll OFR1 OFFSET1_CH LL_ADC_GetOffsetChannel<br  />
 OFR2 OFFSET2_CH LL_ADC_GetOffsetChannel<br  />
 OFR3 OFFSET3_CH LL_ADC_GetOffsetChannel<br  />
 OFR4 OFFSET4_CH LL_ADC_GetOffsetChannel </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Offsety</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_1 </li>
<li>LL_ADC_OFFSET_2 </li>
<li>LL_ADC_OFFSET_3 </li>
<li>LL_ADC_OFFSET_4 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 (7) </li>
<li>LL_ADC_CHANNEL_2 (7) </li>
<li>LL_ADC_CHANNEL_3 (7) </li>
<li>LL_ADC_CHANNEL_4 (7) </li>
<li>LL_ADC_CHANNEL_5 (7) </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (4) </li>
<li>LL_ADC_CHANNEL_VBAT (4) </li>
<li>LL_ADC_CHANNEL_DAC1CH1 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH2 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)</li>
</ul>
(1) On STM32L4, parameter available only on ADC instance: ADC1.<br  />
 (2) On STM32L4, parameter available only on ADC instance: ADC2.<br  />
 (3) On STM32L4, parameter available only on ADC instance: ADC3.<br  />
 (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.<br  />
 (5) On STM32L4, parameter available on devices with only 1 ADC instance.<br  />
 (6) On STM32L4, parameter available on devices with several ADC instances.<br  />
 (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)). Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)).<br  />
 (1, 2, 3, 4) For ADC channel read back from ADC register, comparison with internal channel parameter to be done using helper macro __LL_ADC_CHANNEL_INTERNAL_TO_EXTERNAL(). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02934">2934</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;{</div>
<div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;  <span class="keyword">register</span> <span class="keyword">const</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;OFR1, Offsety);</div>
<div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160; </div>
<div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;  <span class="keywordflow">return</span> (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);</div>
<div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gade4feec0ff65eefcbabcc922db8907ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade4feec0ff65eefcbabcc922db8907ed">&#9670;&nbsp;</a></span>LL_ADC_GetOffsetLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetOffsetLevel </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Offsety</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get for the ADC selected offset number 1, 2, 3 or 4: Offset level (offset to be subtracted from the raw converted data). </p>
<dl class="section note"><dt>Note</dt><dd>Caution: Offset format is dependent to ADC resolution: offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0. @rmtoll OFR1 OFFSET1 LL_ADC_GetOffsetLevel<br  />
 OFR2 OFFSET2 LL_ADC_GetOffsetLevel<br  />
 OFR3 OFFSET3 LL_ADC_GetOffsetLevel<br  />
 OFR4 OFFSET4 LL_ADC_GetOffsetLevel </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Offsety</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_1 </li>
<li>LL_ADC_OFFSET_2 </li>
<li>LL_ADC_OFFSET_3 </li>
<li>LL_ADC_OFFSET_4 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Value</td><td>between Min_Data=0x000 and Max_Data=0xFFF </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02960">2960</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;{</div>
<div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;  <span class="keyword">register</span> <span class="keyword">const</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;OFR1, Offsety);</div>
<div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160; </div>
<div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;  <span class="keywordflow">return</span> (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1);</div>
<div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae94a9e185e543ed623c65e6e5f20e5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae94a9e185e543ed623c65e6e5f20e5ba">&#9670;&nbsp;</a></span>LL_ADC_GetOffsetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetOffsetState </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Offsety</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get for the ADC selected offset number 1, 2, 3 or 4: offset state disabled or enabled. @rmtoll OFR1 OFFSET1_EN LL_ADC_GetOffsetState<br  />
 OFR2 OFFSET2_EN LL_ADC_GetOffsetState<br  />
 OFR3 OFFSET3_EN LL_ADC_GetOffsetState<br  />
 OFR4 OFFSET4_EN LL_ADC_GetOffsetState. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Offsety</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_1 </li>
<li>LL_ADC_OFFSET_2 </li>
<li>LL_ADC_OFFSET_3 </li>
<li>LL_ADC_OFFSET_4 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_OFFSET_DISABLE </li>
<li>LL_ADC_OFFSET_ENABLE </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03019">3019</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03020"></a><span class="lineno"> 3020</span>&#160;{</div>
<div class="line"><a name="l03021"></a><span class="lineno"> 3021</span>&#160;  <span class="keyword">register</span> <span class="keyword">const</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;OFR1, Offsety);</div>
<div class="line"><a name="l03022"></a><span class="lineno"> 3022</span>&#160; </div>
<div class="line"><a name="l03023"></a><span class="lineno"> 3023</span>&#160;  <span class="keywordflow">return</span> (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_EN);</div>
<div class="line"><a name="l03024"></a><span class="lineno"> 3024</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga343cabf2e971a2274d2d66117ca5d857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga343cabf2e971a2274d2d66117ca5d857">&#9670;&nbsp;</a></span>LL_ADC_GetResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetResolution </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC resolution. Refer to reference manual for alignments formats dependencies to ADC resolutions. @rmtoll CFGR RES LL_ADC_GetResolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_RESOLUTION_12B </li>
<li>LL_ADC_RESOLUTION_10B </li>
<li>LL_ADC_RESOLUTION_8B </li>
<li>LL_ADC_RESOLUTION_6B </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02634">2634</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;{</div>
<div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;CFGR, ADC_CFGR_RES));</div>
<div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf9ae1e7bd9f990def1799ec4824ebaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9ae1e7bd9f990def1799ec4824ebaef">&#9670;&nbsp;</a></span>LL_ADC_GetSamplingTimeCommonConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t LL_ADC_GetSamplingTimeCommonConfig </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ADC sampling time common configuration impacting settings of sampling time channel wise. @rmtoll SMPR1 SMPPLUS LL_ADC_GetSamplingTimeCommonConfig. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Returned</td><td>value can be one of the following values: <ul>
<li>LL_ADC_SAMPLINGTIME_COMMON_DEFAULT </li>
<li>LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03055">3055</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03056"></a><span class="lineno"> 3056</span>&#160;{</div>
<div class="line"><a name="l03057"></a><span class="lineno"> 3057</span>&#160;  <span class="keywordflow">return</span> (uint32_t)(READ_BIT(ADCx-&gt;SMPR1, ADC_SMPR1_SMPPLUS));</div>
<div class="line"><a name="l03058"></a><span class="lineno"> 3058</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga824344d3c7ce755028ee08d47db919ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824344d3c7ce755028ee08d47db919ef">&#9670;&nbsp;</a></span>LL_ADC_SetCalibrationFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetCalibrationFactor </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SingleDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>CalibrationFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC calibration factor in the mode single-ended or differential (for devices with differential mode available). </p>
<dl class="section note"><dt>Note</dt><dd>This function is intended to set calibration parameters without having to perform a new calibration using <a class="el" href="group__ADC__LL__EF__Operation__ADC__Instance.html#ga0ec7b7d7c4207b4f36121d82bfe3a9e0">LL_ADC_StartCalibration()</a>. </dd>
<dd>
For devices with differential mode available: Calibration of offset is specific to each of single-ended and differential modes (calibration factor must be specified for each of these differential modes, if used afterwards and if the application requires their calibration). </dd>
<dd>
In case of setting calibration factors of both modes single ended and differential (parameter LL_ADC_BOTH_SINGLE_DIFF_ENDED): both calibration factors must be concatenated. To perform this processing, use helper macro __LL_ADC_CALIB_FACTOR_SINGLE_DIFF(). </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be enabled, without calibration on going, without conversion on going on group regular. @rmtoll CALFACT CALFACT_S LL_ADC_SetCalibrationFactor<br  />
 CALFACT CALFACT_D LL_ADC_SetCalibrationFactor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SingleDiff</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_SINGLE_ENDED </li>
<li>LL_ADC_DIFFERENTIAL_ENDED </li>
<li>LL_ADC_BOTH_SINGLE_DIFF_ENDED </li>
</ul>
</td></tr>
    <tr><td class="paramname">CalibrationFactor</td><td>Value between Min_Data=0x00 and Max_Data=0x7F </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02568">2568</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;{</div>
<div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CALFACT,</div>
<div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;             SingleDiff &amp; ADC_SINGLEDIFF_CALIB_FACTOR_MASK,</div>
<div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;             CalibrationFactor &lt;&lt; (((SingleDiff &amp; ADC_SINGLEDIFF_CALIB_F_BIT_D_MASK) &gt;&gt; ADC_SINGLEDIFF_CALIB_F_BIT_D_SHIFT4) &amp; ~(SingleDiff &amp; ADC_CALFACT_CALFACT_S)));</div>
<div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaf6b8586d5462e96b4d55b66f1444d69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6b8586d5462e96b4d55b66f1444d69c">&#9670;&nbsp;</a></span>LL_ADC_SetDataAlignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetDataAlignment </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>DataAlignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC conversion data alignment. </p>
<dl class="section note"><dt>Note</dt><dd>Refer to reference manual for alignments formats dependencies to ADC resolutions. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll CFGR ALIGN LL_ADC_SetDataAlignment </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">DataAlignment</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_DATA_ALIGN_RIGHT </li>
<li>LL_ADC_DATA_ALIGN_LEFT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02654">2654</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;{</div>
<div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_ALIGN, DataAlignment);</div>
<div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa4d82777c28b1031b961ad1cdb0af174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4d82777c28b1031b961ad1cdb0af174">&#9670;&nbsp;</a></span>LL_ADC_SetLowPowerMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetLowPowerMode </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>LowPowerMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC low power mode. </p>
<dl class="section note"><dt>Note</dt><dd>Description of ADC low power modes:<ul>
<li>ADC low power mode "auto wait": Dynamic low power mode, ADC conversions occurrences are limited to the minimum necessary in order to reduce power consumption. New ADC conversion starts only when the previous unitary conversion data (for ADC group regular) or previous sequence conversions data (for ADC group injected) has been retrieved by user software. In the meantime, ADC remains idle: does not performs any other conversion. This mode allows to automatically adapt the ADC conversions triggers to the speed of the software that reads the data. Moreover, this avoids risk of overrun for low frequency applications. How to use this low power mode:<ul>
<li>Do not use with interruption or DMA since these modes have to clear immediately the EOC flag to free the IRQ vector sequencer.</li>
<li>Do use with polling: 1. Start conversion,<ol type="1">
<li>Later on, when conversion data is needed: poll for end of conversion to ensure that conversion is completed and retrieve ADC conversion data. This will trig another ADC conversion start.</li>
</ol>
</li>
</ul>
</li>
<li>ADC low power mode "auto power-off" (feature available on this device if parameter LL_ADC_LP_AUTOPOWEROFF is available): the ADC automatically powers-off after a conversion and automatically wakes up when a new conversion is triggered (with startup time between trigger and start of sampling). This feature can be combined with low power mode "auto wait". </li>
</ul>
</dd>
<dd>
With ADC low power mode "auto wait", the ADC conversion data read is corresponding to previous ADC conversion start, independently of delay during which ADC was idle. Therefore, the ADC conversion data may be outdated: does not correspond to the current voltage level on the selected ADC channel. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll CFGR AUTDLY LL_ADC_SetLowPowerMode </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">LowPowerMode</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_LP_MODE_NONE </li>
<li>LL_ADC_LP_AUTOWAIT </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02722">2722</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;{</div>
<div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_AUTDLY, LowPowerMode);</div>
<div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2ce2d283f23c049109b92f44c593a54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ce2d283f23c049109b92f44c593a54d">&#9670;&nbsp;</a></span>LL_ADC_SetOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetOffset </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>OffsetLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC selected offset number 1, 2, 3 or 4. </p>
<dl class="section note"><dt>Note</dt><dd>This function set the 2 items of offset configuration:<ul>
<li>ADC channel to which the offset programmed will be applied (independently of channel mapped on ADC group regular or group injected)</li>
<li>Offset level (offset to be subtracted from the raw converted data). </li>
</ul>
</dd>
<dd>
Caution: Offset format is dependent to ADC resolution: offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0. </dd>
<dd>
This function enables the offset, by default. It can be forced to disable state using function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#gac2fc70a0921b99d1180ae9f0e6448fc2" title="Set for the ADC selected offset number 1, 2, 3 or 4: force offset state disable or enable without mod...">LL_ADC_SetOffsetState()</a>. </dd>
<dd>
If a channel is mapped on several offsets numbers, only the offset with the lowest value is considered for the subtraction. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. </dd>
<dd>
On STM32L4, some fast channels are available: fast analog inputs coming from GPIO pads (ADC_IN1..5). @rmtoll OFR1 OFFSET1_CH LL_ADC_SetOffset<br  />
 OFR1 OFFSET1 LL_ADC_SetOffset<br  />
 OFR1 OFFSET1_EN LL_ADC_SetOffset<br  />
 OFR2 OFFSET2_CH LL_ADC_SetOffset<br  />
 OFR2 OFFSET2 LL_ADC_SetOffset<br  />
 OFR2 OFFSET2_EN LL_ADC_SetOffset<br  />
 OFR3 OFFSET3_CH LL_ADC_SetOffset<br  />
 OFR3 OFFSET3 LL_ADC_SetOffset<br  />
 OFR3 OFFSET3_EN LL_ADC_SetOffset<br  />
 OFR4 OFFSET4_CH LL_ADC_SetOffset<br  />
 OFR4 OFFSET4 LL_ADC_SetOffset<br  />
 OFR4 OFFSET4_EN LL_ADC_SetOffset </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Offsety</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_1 </li>
<li>LL_ADC_OFFSET_2 </li>
<li>LL_ADC_OFFSET_3 </li>
<li>LL_ADC_OFFSET_4 </li>
</ul>
</td></tr>
    <tr><td class="paramname">Channel</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_CHANNEL_0 </li>
<li>LL_ADC_CHANNEL_1 (7) </li>
<li>LL_ADC_CHANNEL_2 (7) </li>
<li>LL_ADC_CHANNEL_3 (7) </li>
<li>LL_ADC_CHANNEL_4 (7) </li>
<li>LL_ADC_CHANNEL_5 (7) </li>
<li>LL_ADC_CHANNEL_6 </li>
<li>LL_ADC_CHANNEL_7 </li>
<li>LL_ADC_CHANNEL_8 </li>
<li>LL_ADC_CHANNEL_9 </li>
<li>LL_ADC_CHANNEL_10 </li>
<li>LL_ADC_CHANNEL_11 </li>
<li>LL_ADC_CHANNEL_12 </li>
<li>LL_ADC_CHANNEL_13 </li>
<li>LL_ADC_CHANNEL_14 </li>
<li>LL_ADC_CHANNEL_15 </li>
<li>LL_ADC_CHANNEL_16 </li>
<li>LL_ADC_CHANNEL_17 </li>
<li>LL_ADC_CHANNEL_18 </li>
<li>LL_ADC_CHANNEL_VREFINT (1) </li>
<li>LL_ADC_CHANNEL_TEMPSENSOR (4) </li>
<li>LL_ADC_CHANNEL_VBAT (4) </li>
<li>LL_ADC_CHANNEL_DAC1CH1 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH2 (5) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC2 (2)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH1_ADC3 (3)(6) </li>
<li>LL_ADC_CHANNEL_DAC1CH2_ADC3 (3)(6)</li>
</ul>
(1) On STM32L4, parameter available only on ADC instance: ADC1.<br  />
 (2) On STM32L4, parameter available only on ADC instance: ADC2.<br  />
 (3) On STM32L4, parameter available only on ADC instance: ADC3.<br  />
 (4) On STM32L4, parameter available only on ADC instances: ADC1, ADC3.<br  />
 (5) On STM32L4, parameter available on devices with only 1 ADC instance.<br  />
 (6) On STM32L4, parameter available on devices with several ADC instances.<br  />
 (7) On STM32L4, fast channel (0.188 us for 12-bit resolution (ADC conversion rate up to 5.33 Ms/s)). Other channels are slow channels (0.238 us for 12-bit resolution (ADC conversion rate up to 4.21 Ms/s)). </td></tr>
    <tr><td class="paramname">OffsetLevel</td><td>Value between Min_Data=0x000 and Max_Data=0xFFF </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02855">2855</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;{</div>
<div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;  <span class="keyword">register</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;OFR1, Offsety);</div>
<div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160; </div>
<div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(*preg,</div>
<div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;             ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1,</div>
<div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;             ADC_OFR1_OFFSET1_EN | (Channel &amp; ADC_CHANNEL_ID_NUMBER_MASK) | OffsetLevel);</div>
<div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gac2fc70a0921b99d1180ae9f0e6448fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2fc70a0921b99d1180ae9f0e6448fc2">&#9670;&nbsp;</a></span>LL_ADC_SetOffsetState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetOffsetState </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Offsety</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>OffsetState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set for the ADC selected offset number 1, 2, 3 or 4: force offset state disable or enable without modifying offset channel or offset value. </p>
<dl class="section note"><dt>Note</dt><dd>This function should be needed only in case of offset to be enabled-disabled dynamically, and should not be needed in other cases: function <a class="el" href="group__ADC__LL__EF__Configuration__ADC__Instance.html#ga2ce2d283f23c049109b92f44c593a54d" title="Set ADC selected offset number 1, 2, 3 or 4.">LL_ADC_SetOffset()</a> automatically enables the offset. </dd>
<dd>
On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll OFR1 OFFSET1_EN LL_ADC_SetOffsetState<br  />
 OFR2 OFFSET2_EN LL_ADC_SetOffsetState<br  />
 OFR3 OFFSET3_EN LL_ADC_SetOffsetState<br  />
 OFR4 OFFSET4_EN LL_ADC_SetOffsetState </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Offsety</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_1 </li>
<li>LL_ADC_OFFSET_2 </li>
<li>LL_ADC_OFFSET_3 </li>
<li>LL_ADC_OFFSET_4 </li>
</ul>
</td></tr>
    <tr><td class="paramname">OffsetState</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_OFFSET_DISABLE </li>
<li>LL_ADC_OFFSET_ENABLE </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02993">2993</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;{</div>
<div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;  <span class="keyword">register</span> __IO uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx-&gt;OFR1, Offsety);</div>
<div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160; </div>
<div class="line"><a name="l02997"></a><span class="lineno"> 2997</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(*preg,</div>
<div class="line"><a name="l02998"></a><span class="lineno"> 2998</span>&#160;             ADC_OFR1_OFFSET1_EN,</div>
<div class="line"><a name="l02999"></a><span class="lineno"> 2999</span>&#160;             OffsetState);</div>
<div class="line"><a name="l03000"></a><span class="lineno"> 3000</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9b46d0fa39d1ea30f8e20a596f48e2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b46d0fa39d1ea30f8e20a596f48e2e3">&#9670;&nbsp;</a></span>LL_ADC_SetResolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetResolution </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>Resolution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC resolution. Refer to reference manual for alignments formats dependencies to ADC resolutions. </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll CFGR RES LL_ADC_SetResolution </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">Resolution</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_RESOLUTION_12B </li>
<li>LL_ADC_RESOLUTION_10B </li>
<li>LL_ADC_RESOLUTION_8B </li>
<li>LL_ADC_RESOLUTION_6B </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l02617">2617</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;{</div>
<div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;CFGR, ADC_CFGR_RES, Resolution);</div>
<div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaa22c65073526025e556237cc897e71d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22c65073526025e556237cc897e71d9">&#9670;&nbsp;</a></span>LL_ADC_SetSamplingTimeCommonConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void LL_ADC_SetSamplingTimeCommonConfig </td>
          <td>(</td>
          <td class="paramtype">ADC_TypeDef *&#160;</td>
          <td class="paramname"><em>ADCx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>SamplingTimeCommonConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set ADC sampling time common configuration impacting settings of sampling time channel wise. </p>
<dl class="section note"><dt>Note</dt><dd>On this STM32 serie, setting of this feature is conditioned to ADC state: ADC must be disabled or enabled without conversion on going on either groups regular or injected. @rmtoll SMPR1 SMPPLUS LL_ADC_SetSamplingTimeCommonConfig </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ADCx</td><td>ADC instance </td></tr>
    <tr><td class="paramname">SamplingTimeCommonConfig</td><td>This parameter can be one of the following values: <ul>
<li>LL_ADC_SAMPLINGTIME_COMMON_DEFAULT </li>
<li>LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5 </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="stm32l4xx__ll__adc_8h_source.html#l03041">3041</a> of file <a class="el" href="stm32l4xx__ll__adc_8h_source.html">stm32l4xx_ll_adc.h</a>.</p>
<div class="fragment"><div class="line"><a name="l03042"></a><span class="lineno"> 3042</span>&#160;{</div>
<div class="line"><a name="l03043"></a><span class="lineno"> 3043</span>&#160;  <a class="code" href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a>(ADCx-&gt;SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);</div>
<div class="line"><a name="l03044"></a><span class="lineno"> 3044</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__RTCEx__Exported__Functions__Group2_html_gaf0bea6a9989d50f8ffa9b2afc911fc4b"><div class="ttname"><a href="group__RTCEx__Exported__Functions__Group2.html#gaf0bea6a9989d50f8ffa9b2afc911fc4b">MODIFY_REG</a></div><div class="ttdeci">MODIFY_REG(hrtc-&gt;Instance-&gt;CR, RTC_CR_WUCKSEL,(uint32_t) WakeUpClock)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
